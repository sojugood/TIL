데이터 구조 1

데이터 구조 : 여러 데이터를 효과적으로 사용, 관리하기 위한 구조(str, list, dict 등)

자료 구조
 - 컴퓨터 공학에서는 '자료 구조'라고 함
 - 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것

데이터 구조 활용
 - 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용하기

메서드 : 객체에 속한 함수 -> 객체의 상태를 조작하거나 동작을 수행

메서드 특징
 - 메서드는 클래스(class) 내부에 정의되는 함수
 - 클래스는 파이썬에서 '타입을 표현하는 방법'이며 이미 은연중에 사용해왔음
 - 예를 들어 help 함수를 통해 str을 호출해보면 class 였다는 것을 확인 가능

메서드는 어딘가(클래스)에 속해 있는 함수이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재

메서드 호출 방법
 - 데이터 타입 객체.메서드()

문자열

 문자열 조회 / 탐색 및 검증 메서드
 - .find(x) : x의 첫 번째 위치를 반환. 없으면, -1을 반환
 - .index(x) : x의 첫 번째 위치를 반환. 없으면, 오류 발생
 - .isalpha() : 알파벳 문자 여부 *단순 알파벳이 아닌 유니코드 상 Letter(한국어도 포함)
 - .isupper() : 대문자 여부
 - .islower() : 소문자 여부
 - .istitle() : 타이틀 형식 여부

 문자열 조작 메서드(새 문자열 반환)
 - .replace(old, new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  ! count 인자가 주어진 경우, 해당 문자열에서 왼쪽부터 old를 찾아 new로 최대 count 번만큼 바꿈
 - .strip([chars]) : 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
 - .split(sep=None, maxsplit=-1) : 지정한 문자를 구분자로 문자열을 분리하여 문자열의 리스트로 반환
 - 'separator'.join([iterable]) : iterable 요소들을 원래의 문자열을 구분자로 이용하여 하나의 문자열로 연결
 - 25p 이어서 적기
 메서드는 이어서 사용 가능(chain)


리스트

 리스트 값 추가 및 삭제 메서드
 - .append(x) : 리스트 마지막에 항목 x를 추가
 - .extend(iterable) : 리스트에 다른 반복 가능한 객체의 모든 항목을 추가
  ! append에 리스트를 넣으면 리스트 안에 리스트를 추가함. extend에 리스트를 넣으면 리스트가 연장됨
 - .insert(i, x) : 리스트의 지정한 인덱스 위치에 항목 x를 삽입
 - .remove(x) : 리스트에서 첫 번째로 일치하는 항목을 삭제
 - .pop(i) : 리스트에서 지정한 인덱스의 항목을 제거하고 '반환' / 작성하지 않을 경우 마지막 항목을 제거
 - .clear() : 리스트의 모든 항목을 삭제

 리스트 탐색 및 정렬 메서드
 - .index(x) : 리스트에서 첫 번째로 일치하는 항목의 인덱스를 반환
 - .count(x) : 리스트에서 항목 x가 등장하는 횟수를 반환
 - .sort() : 원본 리스트를 오름차순으로 정렬 / !! 정렬 구문 따로 선언해주기
  ! 내림차순 : .sort(reverse=True)
 - .reverse() : 리스트의 순서를 역순으로 변경(정렬 X)

문자열에 포함된 문자들의 유형을 판별하는 메서드(46p)


###########

a = [1, 2, [3, 4, 5]]

b = [1, 2]

#b.append(a) # -> a 그대로 갖다 쓰는거
b.extend(a) # -> a 복제본을 만들어서 새로 붙이는 거(얕은복사)

a[1] = 100
a[2][0] = 200

print(b)

###########


오후 정리

c = [1, 2]
d = c

c[0] = 10
print(c, d)

[10, 2] [10, 2]

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

e = [1, 2]
f = e[:]

e[0] = 10
print(e, f)

[10, 2] [1, 2]

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

g = [1, 2, [3, 4]]
h = g[:] <------ 리스트의 첫 번째 레벨만 복제(얕은 복사) / [3, 4] 는 두 번째 레벨로 복제 안 됨

g[2][0] = 30
print(g, h)

[1, 2, [30, 4]] [1, 2, [30, 4]]

!! 깊은 복사

import copy

i = [1, 2, [3, 4]]
j = copy.deepcopy()

i[2][0] = 30
print(i, j)

[1, 2, [30, 4]] [1, 2, [3, 4]]




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
보충수업

stack(스택) : LIFO(Last In First Out)
 ex) 쌓아올린 접시
 - list 에서 .append(x) -> .pop()

method(메서드) : 객체(str, list, dict..)에 속한 함수 -> 객체의 상태를 조작하거나 동작을 수행
 ! 객체에 따라 적용되는 메서드가 정해져 있음(공용이 아님)

find 와 index : index는 값이 없으면 오류를 발생시킴 -> 잘못된 요청에서 코드가 더 이상 실행되지 않고 오류를 알려주기 위해 필요

# '{separator}'.join(iterable)
numbers = [1, 2, 3, 4, 5]
result = ''.join(map(str, numbers))
       # 주어.동사()
       # str.join(iterable)
print(result)

! 문자열 조작 메서드만의 특징
 - string
	1. sequence 타입 : 순서가 있고, 정렬을 보장 X, index
	2. iterable 속성 : 순회가 가능하다, index 접근
	3. immutable 속성 : 변경 불가능
	# 문자열은 순서가 변경되거나 값이 변경될 때 그 의미자체가 뒤틀릴 수 있다.
 - list -> mutable
 - tuple -> immutable
 # 한 개 이상의 객체를 반환하려고 하면 파이썬이 알아서 tuple로 묶어서 반환한다. ex) return a ** 2, a * 2

문자열 조작 메서드 (새로운 문자열을 반환!!)
.replace <- 원본 문자열을 바꾸는 게 아님. 새로운 변수에 할당하여 복사본을 만드는 것임
.split() <- 문자열을 리스트로 반환('1 2 3 ~ 10' 이라면 10은 인덱스로 뽑아오기 난해함)